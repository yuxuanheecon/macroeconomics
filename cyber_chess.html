<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>CYBER XIANGQI | 红方双步</title>
<!-- 引入科幻字体 -->
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Noto+Serif+SC:wght@700&display=swap" rel="stylesheet">
<style>
    :root {
        --bg-color: #050505;
        --neon-red: #ff0055;
        --neon-cyan: #00f3ff;
        --neon-yellow: #ffee00;
        --neon-green: #00ff9d;
        --grid-line: rgba(0, 243, 255, 0.15);
    }

    body {
        margin: 0;
        background-color: var(--bg-color);
        color: #fff;
        font-family: 'Orbitron', sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        overflow: hidden;
        user-select: none;
    }

    /* 背景动态网格 */
    body::before {
        content: "";
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: 
            linear-gradient(transparent 95%, var(--neon-cyan) 100%),
            linear-gradient(90deg, transparent 95%, var(--neon-cyan) 100%);
        background-size: 40px 40px;
        opacity: 0.05;
        z-index: -1;
        pointer-events: none;
        animation: scan 10s linear infinite;
    }
    @keyframes scan { from { background-position: 0 0; } to { background-position: 0 40px; } }

    /* 界面容器 */
    #game-wrapper {
        position: relative;
        width: 450px;
        height: 700px; /* 增加高度以容纳底部按钮 */
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    /* 顶部 HUD */
    .hud {
        display: flex; justify-content: space-between; width: 100%;
        margin-bottom: 15px;
        font-family: "Noto Serif SC", serif;
    }
    .turn-indicator {
        flex: 1;
        text-align: center;
        padding: 8px 0;
        border: 1px solid #333;
        border-radius: 4px;
        font-size: 14px;
        background: rgba(0,0,0,0.6);
        transition: all 0.3s;
        margin: 0 5px;
        position: relative;
        overflow: hidden;
    }
    .turn-indicator.active {
        border-color: var(--neon-yellow);
        box-shadow: 0 0 15px rgba(255, 238, 0, 0.3);
        color: var(--neon-yellow);
        font-weight: bold;
    }
    .turn-indicator.active::after {
        content: ""; position: absolute; top:0; left:-100%; width:100%; height:100%;
        background: linear-gradient(90deg, transparent, rgba(255,238,0,0.2), transparent);
        animation: shine 1.5s infinite;
    }
    @keyframes shine { 0% { left:-100%; } 100% { left:100%; } }

    /* 棋盘 Canvas */
    canvas {
        border-radius: 4px;
        box-shadow: 0 0 30px rgba(0, 243, 255, 0.15);
        background: rgba(0, 0, 0, 0.8);
        border: 1px solid #333;
        z-index: 10;
    }

    /* 底部控制栏 (移除了原来的右上角按钮) */
    .controls-bottom {
        margin-top: 15px;
        width: 100%;
        display: flex;
        justify-content: center;
    }

    /* 按钮样式 */
    .cyber-btn {
        background: transparent;
        border: 1px solid var(--neon-cyan);
        color: var(--neon-cyan);
        padding: 10px 30px;
        font-family: 'Orbitron', sans-serif;
        font-size: 0.9rem;
        cursor: pointer;
        transition: all 0.2s;
        position: relative;
        overflow: hidden;
        text-transform: uppercase;
        letter-spacing: 2px;
    }
    .cyber-btn:hover {
        background: var(--neon-cyan);
        color: #000;
        box-shadow: 0 0 20px var(--neon-cyan);
    }
    .cyber-btn-red {
        border-color: var(--neon-red);
        color: var(--neon-red);
    }
    .cyber-btn-red:hover {
        background: var(--neon-red);
        color: #fff;
        box-shadow: 0 0 20px var(--neon-red);
    }

    /* 开始菜单 */
    #start-screen {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(5, 5, 10, 0.95);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
        backdrop-filter: blur(10px);
        border: 1px solid var(--neon-cyan);
        box-shadow: 0 0 50px rgba(0, 243, 255, 0.2);
    }

    h1 {
        font-size: 2.5rem; margin-bottom: 5px;
        color: var(--neon-cyan); text-shadow: 0 0 15px var(--neon-cyan);
        letter-spacing: 4px;
    }
    
    .rules-box {
        width: 85%; text-align: left; font-size: 0.9rem; color: #ccc;
        line-height: 1.8; border-left: 3px solid var(--neon-red);
        padding-left: 20px; margin-bottom: 40px;
        background: linear-gradient(90deg, rgba(255,0,85,0.1), transparent);
    }

    .btn-group { display: flex; gap: 20px; }

    /* 胜利动画层 */
    #victory-overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; z-index: 50;
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        opacity: 0; transition: opacity 0.5s;
    }
    #victory-text {
        font-size: 4rem; font-weight: 900;
        text-shadow: 0 0 20px currentColor;
        transform: scale(0); transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    .glitch { position: relative; }
    .glitch::before, .glitch::after {
        content: attr(data-text); position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    }
    .glitch::before { left: 2px; text-shadow: -1px 0 red; clip: rect(24px, 550px, 90px, 0); animation: glitch-anim 2s infinite linear alternate-reverse; }
    .glitch::after { left: -2px; text-shadow: -1px 0 blue; clip: rect(85px, 550px, 140px, 0); animation: glitch-anim 2s infinite linear alternate-reverse; }
    
    @keyframes glitch-anim {
        0% { clip: rect(12px, 9999px, 55px, 0); }
        20% { clip: rect(89px, 9999px, 100px, 0); }
        40% { clip: rect(4px, 9999px, 86px, 0); }
        60% { clip: rect(67px, 9999px, 22px, 0); }
        80% { clip: rect(33px, 9999px, 11px, 0); }
        100% { clip: rect(102px, 9999px, 85px, 0); }
    }

</style>
</head>
<body>

<div id="game-wrapper">
    <!-- 顶部状态栏 -->
    <div class="hud">
        <div id="indicator-red" class="turn-indicator active">
            <div style="color:var(--neon-red); font-weight:bold;">RED UNIT</div>
            <div style="font-size:0.8em; color:#aaa; margin-top:2px;">步数剩余: <span id="moves-left" style="color:#fff">2</span></div>
        </div>
        <div id="indicator-black" class="turn-indicator">
            <div style="color:var(--neon-cyan); font-weight:bold;">BLACK LEGION</div>
            <div style="font-size:0.8em; color:#aaa; margin-top:2px;">DEFENDING</div>
        </div>
    </div>

    <!-- 棋盘 -->
    <canvas id="chessBoard" width="450" height="500"></canvas>
    
    <!-- 胜利层 -->
    <div id="victory-overlay">
        <div id="victory-text" class="glitch" data-text="VICTORY">VICTORY</div>
    </div>

    <!-- 底部按钮 -->
    <div class="controls-bottom">
        <button class="cyber-btn" onclick="showStartScreen()">SYSTEM REBOOT</button>
    </div>

    <!-- 开始菜单 -->
    <div id="start-screen">
        <h1>CYBER XIANGQI</h1>
        <div style="color:var(--neon-red); margin-bottom:20px; font-size:1rem; letter-spacing:2px;">// PROJECT: DOUBLE STEP //</div>
        
        <div class="rules-box">
            <strong style="color:#fff; font-size:1.1rem;">作战协议 (PROTOCOL):</strong><br><br>
            1. <span style="color:var(--neon-red)">RED (红方)</span>: 装备了「时空加速引擎」，每回合必须执行 <strong>2 次移动</strong>。<br>
            2. <span style="color:var(--neon-cyan)">BLACK (黑方)</span>: 标准防御阵型，虽然单步移动，但兵力是红方的数倍。<br>
            3. <span style="color:var(--neon-yellow)">VICTORY (胜利)</span>: 击碎敌方将领 (King) 核心。<br>
            <br>
            <em style="font-size:0.8em; color:#666;">*注意：红方第一步吃将即刻获胜。禁止将帅照面。</em>
        </div>

        <div class="btn-group">
            <button class="cyber-btn cyber-btn-red" onclick="startGame('pvp')">PVP (人人)</button>
            <button class="cyber-btn" onclick="startGame('pve')">PVE (人机)</button>
        </div>
    </div>
</div>

<script>
/* --- 1. 配置与常量 --- */
const CANVAS_WIDTH = 450;
const CANVAS_HEIGHT = 500;
const GRID_SIZE = 50;
const OFFSET_X = 25;
const OFFSET_Y = 25;

const RED = 1;
const BLACK = -1;
const EMPTY = 0;

const PIECES = {
    1: { txt: "帅", color: "#ff0055" }, 
    2: { txt: "仕", color: "#ff0055" }, 
    3: { txt: "相", color: "#ff0055" }, 
    4: { txt: "马", color: "#ff0055" }, 
    5: { txt: "车", color: "#ff0055" }, 
    6: { txt: "炮", color: "#ff0055" }, 
    7: { txt: "兵", color: "#ff0055" },
    
    [-1]: { txt: "将", color: "#00f3ff" },
    [-2]: { txt: "士", color: "#00f3ff" },
    [-3]: { txt: "象", color: "#00f3ff" },
    [-4]: { txt: "马", color: "#00f3ff" },
    [-5]: { txt: "车", color: "#00f3ff" },
    [-6]: { txt: "炮", color: "#00f3ff" },
    [-7]: { txt: "卒", color: "#00f3ff" }
};

/* --- 2. 状态管理 --- */
let board = []; 
let visualBoard = []; 
let currentTurn = RED;
let redMovesLeft = 2;
let selectedPiece = null;
let gameMode = 'pvp';
let gameOver = false;
let lastMove = null;
let particles = []; 

const canvas = document.getElementById('chessBoard');
const ctx = canvas.getContext('2d');

/* --- 3. 核心流程 --- */

function showStartScreen() {
    document.getElementById('start-screen').style.display = 'flex';
    document.getElementById('victory-overlay').style.opacity = 0;
    gameOver = false;
}

function startGame(mode) {
    gameMode = mode;
    document.getElementById('start-screen').style.display = 'none';
    initBoard();
    animate(); 
}

function initBoard() {
    board = Array(10).fill(null).map(() => Array(9).fill(EMPTY));
    
    // 黑方 (标准)
    const br0 = [-5, -4, -3, -2, -1, -2, -3, -4, -5];
    const br2 = [0, -6, 0, 0, 0, 0, 0, -6, 0];
    const br3 = [-7, 0, -7, 0, -7, 0, -7, 0, -7];
    
    for(let c=0; c<9; c++) {
        board[0][c] = { type: br0[c], color: BLACK };
        if(br2[c]!==0) board[2][c] = { type: br2[c], color: BLACK };
        if(br3[c]!==0) board[3][c] = { type: br3[c], color: BLACK };
    }

    // 红方 (变体)
    board[9][4] = { type: 1, color: RED };
    [0, 2, 4, 6, 8].forEach(c => board[6][c] = { type: 7, color: RED });

    // 可视化同步
    visualBoard = [];
    for(let r=0; r<10; r++) {
        for(let c=0; c<9; c++) {
            if(board[r][c] !== EMPTY) {
                visualBoard.push({
                    r:r, c:c, x: c*GRID_SIZE, y: r*GRID_SIZE,
                    targetX: c*GRID_SIZE, targetY: r*GRID_SIZE,
                    data: board[r][c], dead: false
                });
            }
        }
    }
    
    currentTurn = RED; redMovesLeft = 2; gameOver = false; lastMove = null;
    document.getElementById('victory-overlay').style.opacity = 0;
    document.getElementById('victory-text').style.transform = 'scale(0)';
    updateStatus();
}

/* --- 4. 渲染循环 --- */
function animate() {
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    drawBoardBase();
    drawLastMove();
    drawSelection();
    updateAndDrawPieces();
    updateAndDrawParticles();

    requestAnimationFrame(animate);
}

function drawBoardBase() {
    // Grid
    ctx.shadowBlur = 10; ctx.shadowColor = "rgba(0, 243, 255, 0.3)";
    ctx.strokeStyle = "rgba(0, 243, 255, 0.2)"; ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i=0; i<10; i++) { ctx.moveTo(OFFSET_X, OFFSET_Y+i*GRID_SIZE); ctx.lineTo(OFFSET_X+8*GRID_SIZE, OFFSET_Y+i*GRID_SIZE); }
    for (let i=0; i<9; i++) {
        ctx.moveTo(OFFSET_X+i*GRID_SIZE, OFFSET_Y);
        if (i===0 || i===8) ctx.lineTo(OFFSET_X+i*GRID_SIZE, OFFSET_Y+9*GRID_SIZE);
        else {
            ctx.lineTo(OFFSET_X+i*GRID_SIZE, OFFSET_Y+4*GRID_SIZE);
            ctx.moveTo(OFFSET_X+i*GRID_SIZE, OFFSET_Y+5*GRID_SIZE);
            ctx.lineTo(OFFSET_X+i*GRID_SIZE, OFFSET_Y+9*GRID_SIZE);
        }
    }
    // Palaces
    ctx.moveTo(OFFSET_X+3*GRID_SIZE, OFFSET_Y); ctx.lineTo(OFFSET_X+5*GRID_SIZE, OFFSET_Y+2*GRID_SIZE);
    ctx.moveTo(OFFSET_X+5*GRID_SIZE, OFFSET_Y); ctx.lineTo(OFFSET_X+3*GRID_SIZE, OFFSET_Y+2*GRID_SIZE);
    ctx.moveTo(OFFSET_X+3*GRID_SIZE, OFFSET_Y+7*GRID_SIZE); ctx.lineTo(OFFSET_X+5*GRID_SIZE, OFFSET_Y+9*GRID_SIZE);
    ctx.moveTo(OFFSET_X+5*GRID_SIZE, OFFSET_Y+7*GRID_SIZE); ctx.lineTo(OFFSET_X+3*GRID_SIZE, OFFSET_Y+9*GRID_SIZE);
    ctx.stroke(); ctx.shadowBlur = 0;

    // River Text
    ctx.font = "italic 24px Orbitron"; ctx.fillStyle = "rgba(0, 243, 255, 0.2)";
    ctx.textAlign = "center"; ctx.textBaseline = "middle";
    ctx.fillText("CYBER RIVER", OFFSET_X+4*GRID_SIZE, OFFSET_Y+4.5*GRID_SIZE);
}

function updateAndDrawPieces() {
    visualBoard.forEach(p => {
        if (p.dead) return;
        // Lerp
        p.x += (p.targetX - p.x) * 0.2;
        p.y += (p.targetY - p.y) * 0.2;

        const sx = OFFSET_X + p.x; const sy = OFFSET_Y + p.y;
        const def = PIECES[p.data.type];
        
        // Outer Glow
        ctx.shadowBlur = 20; ctx.shadowColor = def.color;
        ctx.beginPath(); ctx.arc(sx, sy, 22, 0, 2*Math.PI);
        ctx.strokeStyle = def.color; ctx.lineWidth = 2; ctx.stroke();

        // Inner Dark
        ctx.beginPath(); ctx.arc(sx, sy, 18, 0, 2*Math.PI);
        ctx.fillStyle = "rgba(10,10,15,0.9)"; ctx.fill();

        // Text
        ctx.shadowBlur = 0; ctx.fillStyle = def.color;
        ctx.font = "bold 22px 'Noto Serif SC'"; ctx.textAlign = "center";
        ctx.fillText(def.txt, sx, sy+2);
    });
}

function drawSelection() {
    if (selectedPiece) {
        const x = OFFSET_X + selectedPiece.c * GRID_SIZE;
        const y = OFFSET_Y + selectedPiece.r * GRID_SIZE;
        ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.setLineDash([5, 5]);
        ctx.strokeRect(x-23, y-23, 46, 46); ctx.setLineDash([]);

        const moves = getValidMoves(selectedPiece.r, selectedPiece.c, board);
        ctx.fillStyle = "rgba(0, 255, 157, 0.5)";
        moves.forEach(m => {
            ctx.beginPath(); ctx.arc(OFFSET_X+m.c*GRID_SIZE, OFFSET_Y+m.r*GRID_SIZE, 6, 0, 2*Math.PI); ctx.fill();
        });
    }
}

function drawLastMove() {
    if (lastMove) {
        ctx.fillStyle = "rgba(255, 255, 255, 0.15)";
        const x1 = OFFSET_X + lastMove.fromC * GRID_SIZE - 25; const y1 = OFFSET_Y + lastMove.fromR * GRID_SIZE - 25;
        const x2 = OFFSET_X + lastMove.toC * GRID_SIZE - 25; const y2 = OFFSET_Y + lastMove.toR * GRID_SIZE - 25;
        ctx.fillRect(x1, y1, 50, 50); ctx.fillRect(x2, y2, 50, 50);
    }
}

/* --- 5. 游戏交互 --- */
canvas.addEventListener('pointerdown', e => {
    if (gameOver) return;
    if (gameMode === 'pve' && currentTurn === BLACK) return;

    const rect = canvas.getBoundingClientRect();
    const c = Math.round((e.clientX - rect.left - OFFSET_X) / GRID_SIZE);
    const r = Math.round((e.clientY - rect.top - OFFSET_Y) / GRID_SIZE);
    
    if (c < 0 || c > 8 || r < 0 || r > 9) return;

    const piece = board[r][c];

    if (piece !== EMPTY && piece.color === currentTurn) {
        selectedPiece = {r, c}; // Select
    } else if (selectedPiece) {
        const moves = getValidMoves(selectedPiece.r, selectedPiece.c, board);
        const move = moves.find(m => m.r === r && m.c === c);
        if (move) executeMove(selectedPiece, move);
    }
});

function executeMove(from, to) {
    const target = board[to.r][to.c];
    
    // Kill Effect
    if (target !== EMPTY) {
        const vTarget = visualBoard.find(p => p.r === to.r && p.c === to.c && !p.dead);
        if(vTarget) vTarget.dead = true;
        spawnParticles(OFFSET_X+to.c*GRID_SIZE, OFFSET_Y+to.r*GRID_SIZE, PIECES[target.type].color);
    }

    // Update Logic
    board[to.r][to.c] = board[from.r][from.c];
    board[from.r][from.c] = EMPTY;
    
    // Update Visual
    const vPiece = visualBoard.find(p => p.r === from.r && p.c === from.c && !p.dead);
    if (vPiece) {
        vPiece.r = to.r; vPiece.c = to.c;
        vPiece.targetX = to.c * GRID_SIZE; vPiece.targetY = to.r * GRID_SIZE;
    }
    
    lastMove = { fromR:from.r, fromC:from.c, toR:to.r, toC:to.c };
    selectedPiece = null;

    // Win Check
    if (target && Math.abs(target.type) === 1) {
        triggerVictory(currentTurn);
        return;
    }

    // Turn Logic
    if (currentTurn === RED) {
        redMovesLeft--;
        if (redMovesLeft === 0) {
            if (checkFlyingGeneral()) return;
            currentTurn = BLACK;
            updateStatus();
            if (gameMode === 'pve') setTimeout(aiMove, 600);
        } else {
            updateStatus();
        }
    } else {
        if (checkFlyingGeneral()) return;
        currentTurn = RED; redMovesLeft = 2;
        updateStatus();
    }
}

function triggerVictory(winner) {
    gameOver = true;
    const overlay = document.getElementById('victory-overlay');
    const text = document.getElementById('victory-text');
    
    overlay.style.opacity = 1;
    overlay.style.pointerEvents = 'auto';
    text.style.transform = 'scale(1)';
    
    const winColor = winner === RED ? '#ff0055' : '#00f3ff';
    text.style.color = winColor;
    text.setAttribute('data-text', winner === RED ? "RED WINS" : "BLACK WINS");
    text.innerText = winner === RED ? "RED WINS" : "BLACK WINS";
    
    spawnFireworks(winColor);
}

function spawnParticles(x, y, color) {
    for(let i=0; i<15; i++) {
        particles.push({
            x, y, vx:(Math.random()-0.5)*8, vy:(Math.random()-0.5)*8,
            color, life: 1.0
        });
    }
}

function spawnFireworks(color) {
    // Center Explosion
    spawnParticles(CANVAS_WIDTH/2, CANVAS_HEIGHT/2, color);
    // Loop
    let fwLoop = setInterval(() => {
        if(!gameOver) clearInterval(fwLoop);
        spawnParticles(Math.random()*CANVAS_WIDTH, Math.random()*CANVAS_HEIGHT, color);
    }, 300);
}

function updateAndDrawParticles() {
    for(let i=particles.length-1; i>=0; i--) {
        let p = particles[i];
        p.x += p.vx; p.y += p.vy; p.life -= 0.02;
        ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
        ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill();
        if(p.life <= 0) particles.splice(i,1);
    }
    ctx.globalAlpha = 1.0;
}

function updateStatus() {
    document.getElementById('indicator-red').classList.toggle('active', currentTurn === RED);
    document.getElementById('indicator-black').classList.toggle('active', currentTurn === BLACK);
    document.getElementById('moves-left').innerText = currentTurn === RED ? `MOVES: ${redMovesLeft}` : "WAITING";
}

/* --- 6. AI & Rules (Simplified) --- */
function checkFlyingGeneral() {
    let rK, bK;
    for(let r=0; r<10; r++) for(let c=0; c<9; c++) {
        const p = board[r][c];
        if(p!==EMPTY && Math.abs(p.type)===1) { if(p.color===RED) rK={r,c}; else bK={r,c}; }
    }
    if(!rK || !bK || rK.c !== bK.c) return false;
    for(let i=Math.min(rK.r,bK.r)+1; i<Math.max(rK.r,bK.r); i++) if(board[i][rK.c]!==EMPTY) return false;
    
    // Facing! Current mover loses instantly.
    triggerVictory(currentTurn === RED ? BLACK : RED); // Opponent wins
    return true;
}

function aiMove() {
    if(gameOver) return;
    // Simple Greedy AI
    let moves = [];
    for(let r=0; r<10; r++) for(let c=0; c<9; c++) {
        if(board[r][c]!==EMPTY && board[r][c].color===BLACK) {
            getValidMoves(r,c,board).forEach(m => moves.push({from:{r,c}, to:m}));
        }
    }
    // Eval
    const vals = {1:10000, 5:90, 6:45, 4:40, 3:20, 2:20, 7:10};
    let best = null; let maxScore = -9999;
    moves.sort(()=>Math.random()-0.5);
    
    for(let m of moves) {
        let score = 0;
        const target = board[m.to.r][m.to.c];
        if(target!==EMPTY) score += vals[target.type]*10;
        if(target!==EMPTY && target.type===1) score += 99999;
        
        // Simulate to check flying general suicide
        const bak = board[m.to.r][m.to.c];
        board[m.to.r][m.to.c] = board[m.from.r][m.from.c];
        board[m.from.r][m.from.c] = EMPTY;
        
        // Flying general check (Self check) - if I expose myself, bad
        // But wait, checkFlyingGeneral function triggers GAME OVER.
        // Here we just want to know if it happens.
        // Let's reuse logic manually
        let rK, bK, obstacle=false;
        for(let rr=0; rr<10; rr++) for(let cc=0; cc<9; cc++) {
           const pp = board[rr][cc];
           if(pp!==EMPTY && Math.abs(pp.type)===1) { if(pp.color===RED) rK={r:rr,c:cc}; else bK={r:rr,c:cc}; }
        }
        if(rK && bK && rK.c===bK.c) {
            for(let i=Math.min(rK.r,bK.r)+1; i<Math.max(rK.r,bK.r); i++) if(board[i][rK.c]!==EMPTY) obstacle=true;
            if(!obstacle) score -= 100000; // Suicide move
        }

        // Restore
        board[m.from.r][m.from.c] = board[m.to.r][m.to.c];
        board[m.to.r][m.to.c] = bak;

        if(score > maxScore) { maxScore = score; best = m; }
    }
    
    if(best) executeMove(best.from, best.to);
    else triggerVictory(RED);
}

function getValidMoves(r, c, bd) {
    const p = bd[r][c]; if(p===EMPTY) return [];
    const type = Math.abs(p.type); const col = p.color;
    let m = [];
    const ok = (nr,nc) => nr>=0&&nr<=9&&nc>=0&&nc<=8 && (bd[nr][nc]===EMPTY || bd[nr][nc].color!==col);

    if(type===1) { // King
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(d=>{
            let nr=r+d[0], nc=c+d[1];
            if(nc>=3&&nc<=5 && ((col===RED&&nr>=7)||(col===BLACK&&nr<=2)) && ok(nr,nc)) m.push({r:nr,c:nc});
        });
    } else if(type===7) { // Pawn
        let fwd = col===RED?-1:1;
        if(ok(r+fwd,c)) m.push({r:r+fwd,c:c});
        if((col===RED&&r<=4)||(col===BLACK&&r>=5)) {
            if(ok(r,c-1)) m.push({r:r,c:c-1}); if(ok(r,c+1)) m.push({r:r,c:c+1});
        }
    } else if(type===5) { // Rook
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(d=>{
            let k=1; while(true){
                let nr=r+d[0]*k, nc=c+d[1]*k;
                if(nr<0||nr>9||nc<0||nc>8) break;
                if(bd[nr][nc]===EMPTY) m.push({r:nr,c:nc});
                else { if(bd[nr][nc].color!==col) m.push({r:nr,c:nc}); break; }
                k++;
            }
        });
    } else if(type===4) { // Horse
        [[-2,-1],[-2,1],[2,-1],[2,1],[-1,-2],[-1,2],[1,-2],[1,2]].forEach(o=>{
            let nr=r+o[0], nc=c+o[1], lr=r+(Math.abs(o[0])===2?Math.sign(o[0]):0), lc=c+(Math.abs(o[1])===2?Math.sign(o[1]):0);
            if(nr>=0&&nr<=9&&nc>=0&&nc<=8 && bd[lr][lc]===EMPTY && ok(nr,nc)) m.push({r:nr,c:nc});
        });
    } else if(type===6) { // Cannon
        [[0,1],[0,-1],[1,0],[-1,0]].forEach(d=>{
            let k=1, jump=false; while(true){
                let nr=r+d[0]*k, nc=c+d[1]*k;
                if(nr<0||nr>9||nc<0||nc>8) break;
                if(!jump) {
                    if(bd[nr][nc]===EMPTY) m.push({r:nr,c:nc}); else jump=true;
                } else {
                    if(bd[nr][nc]!==EMPTY) { if(bd[nr][nc].color!==col) m.push({r:nr,c:nc}); break; }
                }
                k++;
            }
        });
    } else if(type===3) { // Elephant
        [[2,2],[2,-2],[-2,2],[-2,-2]].forEach(o=>{
            let nr=r+o[0], nc=c+o[1], er=r+o[0]/2, ec=c+o[1]/2;
            if(nr>=0&&nr<=9&&nc>=0&&nc<=8 && ((col===RED&&nr>=5)||(col===BLACK&&nr<=4)) && bd[er][ec]===EMPTY && ok(nr,nc)) m.push({r:nr,c:nc});
        });
    } else if(type===2) { // Advisor
        [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(o=>{
            let nr=r+o[0], nc=c+o[1];
            if(nc>=3&&nc<=5 && ((col===RED&&nr>=7)||(col===BLACK&&nr<=2)) && ok(nr,nc)) m.push({r:nr,c:nc});
        });
    }
    return m;
}

// Init
showStartScreen();
</script>
</body>
</html>
